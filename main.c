#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 256
#define MAX_ARGS 10

FILE *fp;

/*
parser: parses command entered by the user.
Since max number of arguments allowed in terminal the arguments array is of size 10.
*/
void parser(char *argv[], char command[]){
    char *arg = strtok(command, " ");

    for (int argc = 0; i < MAX_ARGS; ++argc) {
        if (arg) {
            argv[argc] = arg;
            arg = strtok(NULL, " ");
        } else {
            argv[argc] = NULL;
        }
    }
}

/*
handler: handles SIGCHLD signals generated by the child process when terminate.
The parent process then removes the process which initiated the signal from the processes table.
In case of a zombie process this method is responsible for reaping it.
*/
void handler() {
    while (waitpid((pid_t)(-1), 0, WNOHANG) > 0) {}
    fprintf(fp, "Child process was terminated\n");
}

/*
cd_command: built-in cd command for handling user command to navigate between different directories. 
*/
void cd_command(char *arguments[], char prevdir[]){
    char *curdir, dir[MAX_LENGTH], tmpdir[MAX_LENGTH];

    if (!arguments[1] || !strcmp(arguments[1], "~")){
        curdir = getenv("HOME");
    } else if (!strcmp(arguments[1], "..")) {
        getcwd(dir, sizeof(dir));
        char *ptr = strrchr(dir, '/');
        dir[ptr - dir + (dir == ptr ? 1 : 0)] = '\0';
        curdir = dir;
    } else if (!strcmp(arguments[1], "-")) {
        memcpy(dir, prevdir, sizeof(dir));
        curdir = dir;
        printf("%s", curdir);
    } else {
        curdir = arguments[1];
    }

    getcwd(tmpdir, sizeof(tmpdir));
    if (chdir(curdir)) {
        perror("cd");
        return;
    }

    memcpy(prevdir, tmpdir, sizeof(tmpdir));
}

/*
export_command: built-in export command for hdefining environment variables and using them in child processes.
*/
void export_command(char *arguments[]){
    char name[MAX_LENGTH/2], value[MAX_LENGTH/2];
    char *ptr = strrchr(arguments[1], '='), *end = strchr(arguments[1], '\0');
    memcpy(name, arguments[1], (ptr - arguments[1]) * sizeof(char));
    memcpy(value, ptr+1, (end - (ptr+1)) * sizeof(char));
    name[ptr - arguments[1]] = '\0', value[end - (ptr+1)] = '\0';
    setenv(name, value, 0);
}

/*
echo_command: built-in echo command for printing input line as string of text or value of defined environment variable.
*/
void echo_command(char *arguments[]){
    char *variable;
    for(int i = 1; arguments[i] != NULL; i++){
        if (*arguments[i] == '$') {
            arguments[i]++;
            variable = getenv(arguments[i]);
            if (variable)
                printf("%s ", variable);
            else
                printf("\n");
        } else
            printf("%s", arguments[1]);
    }
}

/*
Driver code.
*/
int main() {

    char prevdir[MAX_LENGTH] = {'\0'};
    signal(SIGCHLD, handler);

    fp = fopen ("g-Shell.log", "w");

    while (1){
        pid_t childPid;
        char command[MAX_COMMAND_LENGTH];
        char *arguments[MAX_ARGS];

        printf("g-Shell > ");
        fgets(command, MAX_COMMAND_LENGTH, stdin);
        command[strcspn(command, "\n")] = '\0';

        parser(arguments, command);

        if (!strcmp(arguments[0], "exit")) {
            exit(0);
        }
        
        if (!strcmp(arguments[0], "cd")) {
            cd_command(arguments, prevdir);
        } else if (!strcmp(arguments[0], "export")) {
            export_command(arguments);
        } else if (!strcmp(arguments[0], "echo")) {
            echo_command(arguments);
        } else {
            childPid = fork();
            if (childPid < 0) {
                perror("fork");
                exit(EXIT_FAILURE);
            } else if (childPid == 0) {
                if (arguments[1] && !strcmp(arguments[1], "&")) {
                    arguments[1] = NULL;
                    printf("process: %d", getpid());
                }

                execvp(arguments[0], arguments)
                perror("exec");
                exit(EXIT_FAILURE);
            } else {
                if (arguments[1] && !strcmp(arguments[1], "&"))
                    continue;

                waitpid(childPid, 0, 0);
            }
        }
    }
}
